---
layout: post
title: __new__和__init__的区别
categories: [python, 面向对象]
description: __new__和__init__的区别
keywords: 面向对象, Python
---

## ``__new__``和``__init__``的区别

```python
class A(object):

    def __new__(cls, *args, **kwargs):
        print('new  A')
        return object.__new__(cls)

    def __init__(self):
        print("init A")
```

### 1. 说明:

1、继承自object的新式类才有``__new__``

2、``__new__``至少要有一个参数``cls``，代表当前类，此参数在实例化时由Python解释器自动识别

3、``__new__``必须要有返回值，返回实例化出来的实例，这点在自己实现``__new__``时要特别注意，可以return父类（通过super(当前类名, cls)）``__new__``出来的实例，或者直接是object的``__new__``出来的实例

4、``__init__``有一个参数self，就是这个``__new__``返回的实例，``__init__``在``__new__``的基础上可以完成一些其它初始化的动作，``__init__``不需要返回值

5、如果``__new__``创建的是当前类的实例，会自动调用``__init__``函数，通过return语句里面调用的``__new__``函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的``__init__``函数，也不会调用其他类的``__init__``函数。

### 2. 在继承派生时的调用顺序

1、在定义子类时没有重新定义``__new__()``时，Python默认是调用该类的直接父类的``__new__()``方法来构造该类的实例，如果该类的父类也没有重写``__new__()``，那么将一直按此规矩追溯至object的``__new__()``方法，因为object是所有新式类的基类。

2、而如果子类中重写了``__new__()``方法，那么你可以自由选择任意一个的其他的新式类（必定要是新式类，只有新式类必定都有``__new__``()，因为所有新式类都是object的后代，而经典类则没有``__new__()``方法）的``__new__()``方法来制造实例，包括这个新式类的所有前代类和后代类，只要它们不会造成递归死循环。反正肯定不能调用自己的``__new__``，这肯定是死循环。

3、对于子类的``__init__``，其调用规则跟``__new__``是一致的，当然如果子类和父类的``__init__``函数都想调用，可以在子类的``__init__``函数中加入对父类``__init__``函数的调用。

4、我们在使用时，尽量使用``__init__``函数，不要去自定义``__new__``函数，因为这两者在继承派生时的特性还是很不一样的。
